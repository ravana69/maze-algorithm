// ------ lib/mersenne.js -------
// Generated by CoffeeScript 1.12.4

/*
This implementation of the Mersenne Twister is a port of the JavaScript
version by Y. Okada. The JavaScript version was itself a port of a
C implementation, by Takuji Nishimura and Makoto Matsumoto.

CoffeeScript port by: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var MersenneTwister;

MersenneTwister = (function() {
  MersenneTwister.prototype.N = 624;

  MersenneTwister.prototype.M = 397;

  MersenneTwister.prototype.MATRIX_A = 0x9908b0df;

  MersenneTwister.prototype.UPPER_MASK = 0x80000000;

  MersenneTwister.prototype.LOWER_MASK = 0x7fffffff;

  function MersenneTwister(seed) {
    this.mt = new Array(this.N);
    this.setSeed(seed);
  }

  MersenneTwister.prototype.unsigned32 = function(n1) {
    if (n1 < 0) {
      return (n1 ^ this.UPPER_MASK) + this.UPPER_MASK;
    } else {
      return n1;
    }
  };

  MersenneTwister.prototype.subtraction32 = function(n1, n2) {
    if (n1 < n2) {
      return this.unsigned32((0x100000000 - (n2 - n1)) % 0xffffffff);
    } else {
      return n1 - n2;
    }
  };

  MersenneTwister.prototype.addition32 = function(n1, n2) {
    return this.unsigned32((n1 + n2) & 0xffffffff);
  };

  MersenneTwister.prototype.multiplication32 = function(n1, n2) {
    var i, l, sum;
    sum = 0;
    for (i = l = 0; l < 32; i = ++l) {
      if ((n1 >>> i) & 0x1) {
        sum = this.addition32(sum, this.unsigned32(n2 << i));
      }
    }
    return sum;
  };

  MersenneTwister.prototype.setSeed = function(seed) {
    if (!seed || typeof seed === "number") {
      return this.seedWithInteger(seed);
    } else {
      return this.seedWithArray(seed);
    }
  };

  MersenneTwister.prototype.defaultSeed = function() {
    var currentDate;
    currentDate = new Date();
    return currentDate.getMinutes() * 60000 + currentDate.getSeconds() * 1000 + currentDate.getMilliseconds();
  };

  MersenneTwister.prototype.seedWithInteger = function(seed) {
    var results;
    this.seed = seed != null ? seed : this.defaultSeed();
    this.mt[0] = this.unsigned32(this.seed & 0xffffffff);
    this.mti = 1;
    results = [];
    while (this.mti < this.N) {
      this.mt[this.mti] = this.addition32(this.multiplication32(1812433253, this.unsigned32(this.mt[this.mti - 1] ^ (this.mt[this.mti - 1] >>> 30))), this.mti);
      this.mti[this.mti] = this.unsigned32(this.mt[this.mti] & 0xffffffff);
      results.push(this.mti++);
    }
    return results;
  };

  MersenneTwister.prototype.seedWithArray = function(key) {
    var _m, i, j, k;
    this.seedWithInteger(19650218);
    i = 1;
    j = 0;
    k = this.N > key.length ? this.N : key.length;
    while (k > 0) {
      _m = this.multiplication32(this.unsigned32(this.mt[i - 1] ^ (this.mt[i - 1] >>> 30)), 1664525);
      this.mt[i] = this.addition32(this.addition32(this.unsigned32(this.mt[i] ^ _m), key[j]), j);
      this.mt[i] = this.unsigned32(this.mt[i] & 0xffffffff);
      i++;
      j++;
      if (i >= this.N) {
        this.mt[0] = this.mt[this.N - 1];
        i = 1;
      }
      if (j >= key.length) {
        j = 0;
      }
      k--;
    }
    k = this.N - 1;
    while (k > 0) {
      this.mt[i] = this.subtraction32(this.unsigned32(this.mt[i] ^ this.multiplication32(this.unsigned32(this.mt[i - 1] ^ (this.mt[i - 1] >>> 30)), 1566083941)), i);
      this.mt[i] = this.unsigned32(this.mt[i] & 0xffffffff);
      i++;
      if (i >= this.N) {
        this.mt[0] = this.mt[this.N - 1];
        i = 1;
      }
    }
    return this.mt[0] = 0x80000000;
  };

  MersenneTwister.prototype.nextInteger = function(upper) {
    var kk, mag01, y;
    if ((upper != null ? upper : 1) < 1) {
      return 0;
    }
    mag01 = [0, this.MATRIX_A];
    if (this.mti >= this.N) {
      kk = 0;
      while (kk < this.N - this.M) {
        y = this.unsigned32((this.mt[kk] & this.UPPER_MASK) | (this.mt[kk + 1] & this.LOWER_MASK));
        this.mt[kk] = this.unsigned32(this.mt[kk + this.M] ^ (y >>> 1) ^ mag01[y & 0x1]);
        kk++;
      }
      while (kk < this.N - 1) {
        y = this.unsigned32((this.mt[kk] & this.UPPER_MASK) | (this.mt[kk + 1] & this.LOWER_MASK));
        this.mt[kk] = this.unsigned32(this.mt[kk + this.M - this.N] ^ (y >>> 1) ^ mag01[y & 0x1]);
        kk++;
      }
      y = this.unsigned32((this.mt[this.N - 1] & this.UPPER_MASK) | (this.mt[0] & this.LOWER_MASK));
      this.mt[this.N - 1] = this.unsigned32(this.mt[this.M - 1] ^ (y >>> 1) ^ mag01[y & 0x1]);
      this.mti = 0;
    }
    y = this.mt[this.mti++];
    y = this.unsigned32(y ^ (y >>> 11));
    y = this.unsigned32(y ^ ((y << 7) & 0x9d2c5680));
    y = this.unsigned32(y ^ ((y << 15) & 0xefc60000));
    return this.unsigned32(y ^ (y >>> 18)) % (upper != null ? upper : 0x100000000);
  };

  MersenneTwister.prototype.nextFloat = function() {
    return this.nextInteger() / 0xffffffff;
  };

  MersenneTwister.prototype.nextBoolean = function() {
    return this.nextInteger() % 2 === 0;
  };

  return MersenneTwister;

})();

// ------ lib/maze.js -------
// Generated by CoffeeScript 1.12.4

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var Maze;

Maze = (function() {
  function Maze(width, height, algorithm, options) {
    this.width = width;
    this.height = height;
    if (options == null) {
      options = {};
    }
    this.grid = new Maze.Grid(this.width, this.height);
    this.rand = options.rng || new MersenneTwister(options.seed);
    this.isWeave = options.weave;
    if (this.rand.randomElement == null) {
      this.rand.randomElement = function(list) {
        return list[this.nextInteger(list.length)];
      };
      this.rand.removeRandomElement = function(list) {
        var results;
        results = list.splice(this.nextInteger(list.length), 1);
        if (results) {
          return results[0];
        }
      };
      this.rand.randomizeList = function(list) {
        var i, j, ref;
        i = list.length - 1;
        while (i > 0) {
          j = this.nextInteger(i + 1);
          ref = [list[j], list[i]], list[i] = ref[0], list[j] = ref[1];
          i--;
        }
        return list;
      };
      this.rand.randomDirections = function() {
        return this.randomizeList(Maze.Direction.List.slice(0));
      };
    }
    this.algorithm = new algorithm(this, options);
  }

  Maze.prototype.onUpdate = function(fn) {
    return this.algorithm.onUpdate(fn);
  };

  Maze.prototype.onEvent = function(fn) {
    return this.algorithm.onEvent(fn);
  };

  Maze.prototype.generate = function() {
    var results1;
    results1 = [];
    while (true) {
      if (!this.step()) {
        break;
      } else {
        results1.push(void 0);
      }
    }
    return results1;
  };

  Maze.prototype.step = function() {
    return this.algorithm.step();
  };

  Maze.prototype.isEast = function(x, y) {
    return this.grid.isMarked(x, y, Maze.Direction.E);
  };

  Maze.prototype.isWest = function(x, y) {
    return this.grid.isMarked(x, y, Maze.Direction.W);
  };

  Maze.prototype.isNorth = function(x, y) {
    return this.grid.isMarked(x, y, Maze.Direction.N);
  };

  Maze.prototype.isSouth = function(x, y) {
    return this.grid.isMarked(x, y, Maze.Direction.S);
  };

  Maze.prototype.isUnder = function(x, y) {
    return this.grid.isMarked(x, y, Maze.Direction.U);
  };

  Maze.prototype.isValid = function(x, y) {
    return (0 <= x && x < this.width) && (0 <= y && y < this.height);
  };

  Maze.prototype.carve = function(x, y, dir) {
    return this.grid.mark(x, y, dir);
  };

  Maze.prototype.uncarve = function(x, y, dir) {
    return this.grid.clear(x, y, dir);
  };

  Maze.prototype.isSet = function(x, y, dir) {
    return this.grid.isMarked(x, y, dir);
  };

  Maze.prototype.isBlank = function(x, y) {
    return this.grid.at(x, y) === 0;
  };

  Maze.prototype.isPerpendicular = function(x, y, dir) {
    return (this.grid.at(x, y) & Maze.Direction.Mask) === Maze.Direction.cross[dir];
  };

  return Maze;

})();

Maze.Algorithms = {};

Maze.Algorithm = (function() {
  function Algorithm(maze1, options) {
    this.maze = maze1;
    if (options == null) {
      options = {};
    }
    this.updateCallback = function(maze, x, y) {};
    this.eventCallback = function(maze, x, y) {};
    this.rand = this.maze.rand;
  }

  Algorithm.prototype.onUpdate = function(fn) {
    return this.updateCallback = fn;
  };

  Algorithm.prototype.onEvent = function(fn) {
    return this.eventCallback = fn;
  };

  Algorithm.prototype.updateAt = function(x, y) {
    return this.updateCallback(this.maze, parseInt(x), parseInt(y));
  };

  Algorithm.prototype.eventAt = function(x, y) {
    return this.eventCallback(this.maze, parseInt(x), parseInt(y));
  };

  Algorithm.prototype.canWeave = function(dir, thruX, thruY) {
    var nx, ny;
    if (this.maze.isWeave && this.maze.isPerpendicular(thruX, thruY, dir)) {
      nx = thruX + Maze.Direction.dx[dir];
      ny = thruY + Maze.Direction.dy[dir];
      return this.maze.isValid(nx, ny) && this.maze.isBlank(nx, ny);
    }
  };

  Algorithm.prototype.performThruWeave = function(thruX, thruY) {
    if (this.rand.nextBoolean()) {
      return this.maze.carve(thruX, thruY, Maze.Direction.U);
    } else if (this.maze.isNorth(thruX, thruY)) {
      this.maze.uncarve(thruX, thruY, Maze.Direction.N | Maze.Direction.S);
      return this.maze.carve(thruX, thruY, Maze.Direction.E | Maze.Direction.W | Maze.Direction.U);
    } else {
      this.maze.uncarve(thruX, thruY, Maze.Direction.E | Maze.Direction.W);
      return this.maze.carve(thruX, thruY, Maze.Direction.N | Maze.Direction.S | Maze.Direction.U);
    }
  };

  Algorithm.prototype.performWeave = function(dir, fromX, fromY, callback) {
    var thruX, thruY, toX, toY;
    thruX = fromX + Maze.Direction.dx[dir];
    thruY = fromY + Maze.Direction.dy[dir];
    toX = thruX + Maze.Direction.dx[dir];
    toY = thruY + Maze.Direction.dy[dir];
    this.maze.carve(fromX, fromY, dir);
    this.maze.carve(toX, toY, Maze.Direction.opposite[dir]);
    this.performThruWeave(thruX, thruY);
    if (callback) {
      callback(toX, toY);
    }
    this.updateAt(fromX, fromY);
    this.updateAt(thruX, thruY);
    return this.updateAt(toX, toY);
  };

  return Algorithm;

})();

Maze.Direction = {
  N: 0x01,
  S: 0x02,
  E: 0x04,
  W: 0x08,
  U: 0x10,
  Mask: 0x01 | 0x02 | 0x04 | 0x08 | 0x10,
  List: [1, 2, 4, 8],
  dx: {
    1: 0,
    2: 0,
    4: 1,
    8: -1
  },
  dy: {
    1: -1,
    2: 1,
    4: 0,
    8: 0
  },
  opposite: {
    1: 2,
    2: 1,
    4: 8,
    8: 4
  },
  cross: {
    1: 4 | 8,
    2: 4 | 8,
    4: 1 | 2,
    8: 1 | 2
  }
};

Maze.Grid = (function() {
  function Grid(width, height) {
    var x, y;
    this.width = width;
    this.height = height;
    this.data = (function() {
      var k, ref, results1;
      results1 = [];
      for (y = k = 1, ref = this.height; 1 <= ref ? k <= ref : k >= ref; y = 1 <= ref ? ++k : --k) {
        results1.push((function() {
          var l, ref1, results2;
          results2 = [];
          for (x = l = 1, ref1 = this.width; 1 <= ref1 ? l <= ref1 : l >= ref1; x = 1 <= ref1 ? ++l : --l) {
            results2.push(0);
          }
          return results2;
        }).call(this));
      }
      return results1;
    }).call(this);
  }

  Grid.prototype.at = function(x, y) {
    return this.data[y][x];
  };

  Grid.prototype.mark = function(x, y, bits) {
    return this.data[y][x] |= bits;
  };

  Grid.prototype.clear = function(x, y, bits) {
    return this.data[y][x] &= ~bits;
  };

  Grid.prototype.isMarked = function(x, y, bits) {
    return (this.data[y][x] & bits) === bits;
  };

  return Grid;

})();

// ------ lib/widget.js -------
// Generated by CoffeeScript 1.12.4

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
Maze.createWidget = function(algorithm, width, height, options) {
  var ACTIONS, element, eventCallback, gridClass, html, id, mazeClass, ref, updateCallback, updateWalls, watch;
  if (options == null) {
    options = {};
  }
  updateWalls = function(maze, x, y, classes) {
    if (maze.isEast(x, y)) {
      classes.push("e");
    }
    if (maze.isWest(x, y)) {
      classes.push("w");
    }
    if (maze.isSouth(x, y)) {
      classes.push("s");
    }
    if (maze.isNorth(x, y)) {
      classes.push("n");
    }
    if (maze.isUnder(x, y)) {
      return classes.push("u");
    }
  };
  ACTIONS = {
    AldousBroder: function(maze, x, y, classes) {
      if (maze.algorithm.isCurrent(x, y)) {
        return classes.push("cursor");
      } else if (!maze.isBlank(x, y)) {
        classes.push("in");
        return updateWalls(maze, x, y, classes);
      }
    },
    GrowingTree: function(maze, x, y, classes) {
      if (!maze.isBlank(x, y)) {
        if (maze.algorithm.inQueue(x, y)) {
          classes.push("f");
        } else {
          classes.push("in");
        }
        return updateWalls(maze, x, y, classes);
      }
    },
    GrowingBinaryTree: function(maze, x, y, classes) {
      return ACTIONS.GrowingTree(maze, x, y, classes);
    },
    HuntAndKill: function(maze, x, y, classes) {
      if (maze.algorithm.isCurrent(x, y)) {
        classes.push("cursor");
      }
      if (!maze.isBlank(x, y)) {
        classes.push("in");
        return updateWalls(maze, x, y, classes);
      }
    },
    Prim: function(maze, x, y, classes) {
      if (maze.algorithm.isFrontier(x, y)) {
        return classes.push("f");
      } else if (maze.algorithm.isInside(x, y)) {
        classes.push("in");
        return updateWalls(maze, x, y, classes);
      }
    },
    RecursiveBacktracker: function(maze, x, y, classes) {
      if (maze.algorithm.isStack(x, y)) {
        classes.push("f");
      } else {
        classes.push("in");
      }
      return updateWalls(maze, x, y, classes);
    },
    RecursiveDivision: function(maze, x, y, classes) {
      return updateWalls(maze, x, y, classes);
    },
    Wilson: function(maze, x, y, classes) {
      if (maze.algorithm.isCurrent(x, y)) {
        classes.push("cursor");
        return updateWalls(maze, x, y, classes);
      } else if (!maze.isBlank(x, y)) {
        classes.push("in");
        return updateWalls(maze, x, y, classes);
      } else if (maze.algorithm.isVisited(x, y)) {
        return classes.push("f");
      }
    },
    Houston: function(maze, x, y, classes) {
      if (maze.algorithm.worker.isVisited != null) {
        return ACTIONS.Wilson(maze, x, y, classes);
      } else {
        return ACTIONS.AldousBroder(maze, x, y, classes);
      }
    },
    "default": function(maze, x, y, classes) {
      if (!maze.isBlank(x, y)) {
        classes.push("in");
        return updateWalls(maze, x, y, classes);
      }
    }
  };
  updateCallback = function(maze, x, y) {
    var cell, classes;
    classes = [];
    (ACTIONS[algorithm] || ACTIONS["default"])(maze, x, y, classes);
    cell = document.getElementById(maze.element.id + "_y" + y + "x" + x);
    return cell.className = classes.join(" ");
  };
  eventCallback = function(maze, x, y) {
    if (maze.element.quickStep) {
      return maze.element.mazePause();
    }
  };
  id = options.id || algorithm.toLowerCase();
  if (options.interval == null) {
    options.interval = 50;
  }
  mazeClass = "maze";
  if (options["class"]) {
    mazeClass += " " + options["class"];
  }
  gridClass = "grid";
  if (options.wallwise) {
    gridClass += " invert";
  }
  if (options.padded) {
    gridClass += " padded";
  }
  if ((ref = options.watch) != null ? ref : true) {
    watch = "<a id='" + id + "_watch' href='#' onclick='document.getElementById(\"" + id + "\").mazeQuickStep(); return false;'>Watch</a>";
  } else {
    watch = "";
  }
  html = "<div id=\"" + id + "\" class=\"" + mazeClass + "\">\n  <div id=\"" + id + "_grid\" class=\"" + gridClass + "\"></div>\n  <div class=\"operations\">\n    <a id=\"" + id + "_reset\" href=\"#\" onclick=\"document.getElementById('" + id + "').mazeReset(); return false;\">Reset</a>\n    <a id=\"" + id + "_step\" href=\"#\" onclick=\"document.getElementById('" + id + "').mazeStep(); return false;\">Step</a>\n    " + watch + "\n    <a id=\"" + id + "_run\" href=\"#\" onclick=\"document.getElementById('" + id + "').mazeRun(); return false;\">Run</a>\n  </div>\n</div>";
  document.write(html);
  element = document.getElementById(id);
  element.addClassName = function(el, name) {
    var className, classNames, i, len;
    classNames = el.className.split(" ");
    for (i = 0, len = classNames.length; i < len; i++) {
      className = classNames[i];
      if (className === name) {
        return;
      }
    }
    return el.className += " " + name;
  };
  element.removeClassName = function(el, name) {
    var className, classNames, i, len, results;
    if (el.className.length > 0) {
      classNames = el.className.split(" ");
      el.className = "";
      results = [];
      for (i = 0, len = classNames.length; i < len; i++) {
        className = classNames[i];
        if (className !== name) {
          if (el.className.length > 0) {
            el.className += " ";
          }
          results.push(el.className += className);
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  };
  element.mazePause = function() {
    if (this.mazeStepInterval != null) {
      clearInterval(this.mazeStepInterval);
      this.mazeStepInterval = null;
      this.quickStep = false;
      return true;
    }
  };
  element.mazeRun = function() {
    if (!this.mazePause()) {
      return this.mazeStepInterval = setInterval(((function(_this) {
        return function() {
          return _this.mazeStep();
        };
      })(this)), options.interval);
    }
  };
  element.mazeStep = function() {
    var ref1;
    if (!this.maze.step()) {
      this.mazePause();
      this.addClassName(document.getElementById(this.id + "_step"), "disabled");
      if ((ref1 = options.watch) != null ? ref1 : true) {
        this.addClassName(document.getElementById(this.id + "_watch"), "disabled");
      }
      return this.addClassName(document.getElementById(this.id + "_run"), "disabled");
    }
  };
  element.mazeQuickStep = function() {
    this.quickStep = true;
    return this.mazeRun();
  };
  element.mazeReset = function() {
    var grid, gridElement, i, j, ref1, ref2, ref3, row_id, value, x, y;
    this.mazePause();
    if (typeof options.input === "function") {
      value = options.input();
    } else {
      value = options.input;
    }
    this.maze = new Maze(width, height, Maze.Algorithms[algorithm], {
      seed: options.seed,
      rng: options.rng,
      input: value,
      weave: options.weave,
      weaveMode: options.weaveMode,
      weaveDensity: options.weaveDensity
    });
    this.maze.element = this;
    this.maze.onUpdate(updateCallback);
    this.maze.onEvent(eventCallback);
    grid = "";
    for (y = i = 0, ref1 = this.maze.height; 0 <= ref1 ? i < ref1 : i > ref1; y = 0 <= ref1 ? ++i : --i) {
      row_id = this.id + "_y" + y;
      grid += "<div class='row' id='" + row_id + "'>";
      for (x = j = 0, ref2 = this.maze.width; 0 <= ref2 ? j < ref2 : j > ref2; x = 0 <= ref2 ? ++j : --j) {
        grid += "<div id='" + row_id + "x" + x + "'>";
        if (options.padded) {
          grid += "<div class='np'></div>";
          grid += "<div class='wp'></div>";
          grid += "<div class='ep'></div>";
          grid += "<div class='sp'></div>";
          grid += "<div class='c'></div>";
        }
        grid += "</div>";
      }
      grid += "</div>";
    }
    gridElement = document.getElementById(this.id + "_grid");
    gridElement.innerHTML = grid;
    this.removeClassName(document.getElementById(this.id + "_step"), "disabled");
    if ((ref3 = options.watch) != null ? ref3 : true) {
      this.removeClassName(document.getElementById(this.id + "_watch"), "disabled");
    }
    return this.removeClassName(document.getElementById(this.id + "_run"), "disabled");
  };
  return element.mazeReset();
};

Maze.createCanvasWidget = function(algorithm, width, height, options) {
  var COLORS, drawCell, drawCellPadded, drawLine, drawMaze, element, eventCallback, gridClass, html, id, mazeClass, ref, ref1, styles, updateCallback, watch;
  if (options == null) {
    options = {};
  }
  styles = (ref = options.styles) != null ? ref : {};
  if (styles.blank == null) {
    styles.blank = "#ccc";
  }
  if (styles.f == null) {
    styles.f = "#faa";
  }
  if (styles.a == null) {
    styles.a = "#faa";
  }
  if (styles.b == null) {
    styles.b = "#afa";
  }
  if (styles["in"] == null) {
    styles["in"] = "#fff";
  }
  if (styles.cursor == null) {
    styles.cursor = "#7f7";
  }
  if (styles.wall == null) {
    styles.wall = "#000";
  }
  COLORS = {
    AldousBroder: function(maze, x, y) {
      if (maze.algorithm.isCurrent(x, y)) {
        return styles.cursor;
      } else if (!maze.isBlank(x, y)) {
        return styles["in"];
      }
    },
    GrowingTree: function(maze, x, y) {
      if (!maze.isBlank(x, y)) {
        if (maze.algorithm.inQueue(x, y)) {
          return styles.f;
        } else {
          return styles["in"];
        }
      }
    },
    GrowingBinaryTree: function(maze, x, y) {
      return COLORS.GrowingTree(maze, x, y);
    },
    HuntAndKill: function(maze, x, y) {
      if (maze.algorithm.isCurrent(x, y)) {
        return styles.cursor;
      } else if (!maze.isBlank(x, y)) {
        return styles["in"];
      }
    },
    Prim: function(maze, x, y) {
      if (maze.algorithm.isFrontier(x, y)) {
        return styles.f;
      } else if (maze.algorithm.isInside(x, y)) {
        return styles["in"];
      }
    },
    RecursiveBacktracker: function(maze, x, y) {
      if (maze.algorithm.isStack(x, y)) {
        return styles.f;
      } else if (!maze.isBlank(x, y)) {
        return styles["in"];
      }
    },
    ParallelBacktracker: function(maze, x, y) {
      var cell, ref1, ref2;
      cell = maze.algorithm.cellAt(x, y);
      if (maze.algorithm.isStack(x, y)) {
        return (ref1 = styles.sets["stack-" + cell.set]) != null ? ref1 : styles.f;
      } else if (!maze.isBlank(x, y)) {
        return (ref2 = styles.sets[cell.set]) != null ? ref2 : "#fff";
      }
    },
    RecursiveDivision: function(maze, x, y) {},
    Wilson: function(maze, x, y) {
      if (maze.algorithm.isCurrent(x, y)) {
        return styles.cursor;
      } else if (!maze.isBlank(x, y)) {
        return styles["in"];
      } else if (maze.algorithm.isVisited(x, y)) {
        return styles.f;
      }
    },
    Houston: function(maze, x, y) {
      if (maze.algorithm.worker != null) {
        if (maze.algorithm.worker.isVisited != null) {
          return COLORS.Wilson(maze, x, y);
        } else {
          return COLORS.AldousBroder(maze, x, y);
        }
      }
    },
    BlobbyDivision: function(maze, x, y) {
      switch (maze.algorithm.stateAt(x, y)) {
        case "blank":
          return styles.blank;
        case "in":
          return styles["in"];
        case "active":
          return styles.f;
        case "a":
          return styles.a;
        case "b":
          return styles.b;
      }
    },
    "default": function(maze, x, y) {
      if (!maze.isBlank(x, y)) {
        return styles["in"];
      }
    }
  };
  drawLine = function(ctx, x1, y1, x2, y2) {
    ctx.moveTo(x1, y1);
    return ctx.lineTo(x2, y2);
  };
  drawCell = function(maze, x, y) {
    var color, colors, empx, nmpy, px, py, smpy, wmpx;
    px = x * maze.cellWidth;
    py = y * maze.cellHeight;
    wmpx = x === 0 ? px + 0.5 : px - 0.5;
    nmpy = y === 0 ? py + 0.5 : py - 0.5;
    empx = px - 0.5;
    smpy = py - 0.5;
    colors = COLORS[algorithm] || COLORS["default"];
    color = colors(maze, x, y);
    if (color == null) {
      color = (options.wallwise ? styles["in"] : styles.blank);
    }
    maze.context.fillStyle = color;
    maze.context.fillRect(px, py, maze.cellWidth, maze.cellHeight);
    maze.context.beginPath();
    if (maze.isWest(x, y) === (options.wallwise != null)) {
      drawLine(maze.context, wmpx, py, wmpx, py + maze.cellHeight);
    }
    if (maze.isEast(x, y) === (options.wallwise != null)) {
      drawLine(maze.context, empx + maze.cellWidth, py, empx + maze.cellWidth, py + maze.cellHeight);
    }
    if (maze.isNorth(x, y) === (options.wallwise != null)) {
      drawLine(maze.context, px, nmpy, px + maze.cellWidth, nmpy);
    }
    if (maze.isSouth(x, y) === (options.wallwise != null)) {
      drawLine(maze.context, px, smpy + maze.cellHeight, px + maze.cellWidth, smpy + maze.cellHeight);
    }
    maze.context.closePath();
    return maze.context.stroke();
  };
  drawCellPadded = function(maze, x, y) {
    var color, colors, px1, px2, px3, px4, py1, py2, py3, py4;
    px1 = x * maze.cellWidth;
    px2 = px1 + maze.insetWidth - 0.5;
    px4 = px1 + maze.cellWidth - 0.5;
    px3 = px4 - maze.insetWidth;
    py1 = y * maze.cellHeight;
    py2 = py1 + maze.insetHeight - 0.5;
    py4 = py1 + maze.cellHeight - 0.5;
    py3 = py4 - maze.insetHeight;
    px1 = x === 0 ? px1 + 0.5 : px1 - 0.5;
    py1 = y === 0 ? py1 + 0.5 : py1 - 0.5;
    colors = COLORS[algorithm] || COLORS["default"];
    color = colors(maze, x, y);
    if (color == null) {
      color = (options.wallwise ? styles["in"] : styles.blank);
    }
    maze.context.fillStyle = color;
    maze.context.fillRect(px2 - 0.5, py2 - 0.5, px3 - px2 + 1, py3 - py2 + 1);
    maze.context.beginPath();
    if (maze.isWest(x, y) || maze.isUnder(x, y)) {
      maze.context.fillRect(px1 - 0.5, py2 - 0.5, px2 - px1 + 1, py3 - py2 + 1);
      drawLine(maze.context, px1 - 1, py2, px2, py2);
      drawLine(maze.context, px1 - 1, py3, px2, py3);
    }
    if (!maze.isWest(x, y)) {
      drawLine(maze.context, px2, py2, px2, py3);
    }
    if (maze.isEast(x, y) || maze.isUnder(x, y)) {
      maze.context.fillRect(px3 - 0.5, py2 - 0.5, px4 - px3 + 1, py3 - py2 + 1);
      drawLine(maze.context, px3, py2, px4 + 1, py2);
      drawLine(maze.context, px3, py3, px4 + 1, py3);
    }
    if (!maze.isEast(x, y)) {
      drawLine(maze.context, px3, py2, px3, py3);
    }
    if (maze.isNorth(x, y) || maze.isUnder(x, y)) {
      maze.context.fillRect(px2 - 0.5, py1 - 0.5, px3 - px2 + 1, py2 - py1 + 1);
      drawLine(maze.context, px2, py1 - 1, px2, py2);
      drawLine(maze.context, px3, py1 - 1, px3, py2);
    }
    if (!maze.isNorth(x, y)) {
      drawLine(maze.context, px2, py2, px3, py2);
    }
    if (maze.isSouth(x, y) || maze.isUnder(x, y)) {
      maze.context.fillRect(px2 - 0.5, py3 - 0.5, px3 - px2 + 1, py4 - py3 + 1);
      drawLine(maze.context, px2, py3, px2, py4 + 1);
      drawLine(maze.context, px3, py3, px3, py4 + 1);
    }
    if (!maze.isSouth(x, y)) {
      drawLine(maze.context, px2, py3, px3, py3);
    }
    maze.context.closePath();
    return maze.context.stroke();
  };
  drawMaze = function(maze) {
    var col, i, ref1, results, row;
    results = [];
    for (row = i = 0, ref1 = maze.height; i < ref1; row = i += 1) {
      results.push((function() {
        var j, ref2, results1;
        results1 = [];
        for (col = j = 0, ref2 = maze.width; j < ref2; col = j += 1) {
          if (options.padded) {
            results1.push(drawCellPadded(maze, col, row));
          } else {
            results1.push(drawCell(maze, col, row));
          }
        }
        return results1;
      })());
    }
    return results;
  };
  updateCallback = function(maze, x, y) {
    if (options.padded) {
      return drawCellPadded(maze, x, y);
    } else {
      return drawCell(maze, x, y);
    }
  };
  eventCallback = function(maze, x, y) {
    if (maze.element.quickStep) {
      return maze.element.mazePause();
    }
  };
  id = options.id || algorithm.toLowerCase();
  if (options.interval == null) {
    options.interval = 50;
  }
  mazeClass = "maze";
  if (options["class"]) {
    mazeClass += " " + options["class"];
  }
  gridClass = "grid";
  if (options.wallwise) {
    gridClass += " invert";
  }
  if (options.padded) {
    gridClass += " padded";
  }
  if ((ref1 = options.watch) != null ? ref1 : true) {
    watch = "<a id='" + id + "_watch' href='#' onclick='document.getElementById(\"" + id + "\").mazeQuickStep(); return false;'>Watch</a>";
  } else {
    watch = "";
  }
  html = "<div id=\"" + id + "\" class=\"" + mazeClass + "\">\n  <canvas id=\"" + id + "_canvas\" width=\"210\" height=\"210\" class=\"" + gridClass + "\"></canvas>\n  <div class=\"operations\">\n    <a id=\"" + id + "_reset\" href=\"#\" onclick=\"document.getElementById('" + id + "').mazeReset(); return false;\">Reset</a>\n    <a id=\"" + id + "_step\" href=\"#\" onclick=\"document.getElementById('" + id + "').mazeStep(); return false;\">Step</a>\n    " + watch + "\n    <a id=\"" + id + "_run\" href=\"#\" onclick=\"document.getElementById('" + id + "').mazeRun(); return false;\">Run</a>\n  </div>\n</div>";
  document.write(html);
  element = document.getElementById(id);
  element.addClassName = function(el, name) {
    var className, classNames, i, len;
    classNames = el.className.split(" ");
    for (i = 0, len = classNames.length; i < len; i++) {
      className = classNames[i];
      if (className === name) {
        return;
      }
    }
    return el.className += " " + name;
  };
  element.removeClassName = function(el, name) {
    var className, classNames, i, len, results;
    if (el.className.length > 0) {
      classNames = el.className.split(" ");
      el.className = "";
      results = [];
      for (i = 0, len = classNames.length; i < len; i++) {
        className = classNames[i];
        if (className !== name) {
          if (el.className.length > 0) {
            el.className += " ";
          }
          results.push(el.className += className);
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  };
  element.mazePause = function() {
    if (this.mazeStepInterval != null) {
      clearInterval(this.mazeStepInterval);
      this.mazeStepInterval = null;
      this.quickStep = false;
      return true;
    }
  };
  element.mazeRun = function() {
    if (!this.mazePause()) {
      return this.mazeStepInterval = setInterval(((function(_this) {
        return function() {
          return _this.mazeStep();
        };
      })(this)), options.interval);
    }
  };
  element.mazeStep = function() {
    var ref2;
    if (!this.maze.step()) {
      this.mazePause();
      this.addClassName(document.getElementById(this.id + "_step"), "disabled");
      if ((ref2 = options.watch) != null ? ref2 : true) {
        this.addClassName(document.getElementById(this.id + "_watch"), "disabled");
      }
      return this.addClassName(document.getElementById(this.id + "_run"), "disabled");
    }
  };
  element.mazeQuickStep = function() {
    this.quickStep = true;
    return this.mazeRun();
  };
  element.mazeReset = function() {
    var canvas, growSpeed, inset, ref2, ref3, threshold, value, wallSpeed;
    this.mazePause();
    if (typeof options.input === "function") {
      value = options.input();
    } else {
      value = options.input;
    }
    if (typeof options.threshold === "function") {
      threshold = options.threshold();
    } else {
      threshold = options.threshold;
    }
    growSpeed = Math.round(Math.sqrt(width * height));
    wallSpeed = Math.round((width < height ? width : height) / 2);
    this.maze = new Maze(width, height, Maze.Algorithms[algorithm], {
      seed: options.seed,
      rng: options.rng,
      input: value,
      weave: options.weave,
      weaveMode: options.weaveMode,
      weaveDensity: options.weaveDensity,
      threshold: threshold,
      growSpeed: growSpeed,
      wallSpeed: wallSpeed
    });
    canvas = document.getElementById(this.id + "_canvas");
    this.maze.element = this;
    this.maze.canvas = canvas;
    this.maze.context = canvas.getContext('2d');
    this.maze.cellWidth = Math.floor(canvas.width / this.maze.width);
    this.maze.cellHeight = Math.floor(canvas.height / this.maze.height);
    if (options.padded) {
      inset = (ref2 = options.inset) != null ? ref2 : 0.1;
      this.maze.insetWidth = Math.ceil(inset * this.maze.cellWidth);
      this.maze.insetHeight = Math.ceil(inset * this.maze.cellHeight);
    }
    this.maze.onUpdate(updateCallback);
    this.maze.onEvent(eventCallback);
    this.maze.context.clearRect(0, 0, canvas.width, canvas.height);
    this.removeClassName(document.getElementById(this.id + "_step"), "disabled");
    if ((ref3 = options.watch) != null ? ref3 : true) {
      this.removeClassName(document.getElementById(this.id + "_watch"), "disabled");
    }
    this.removeClassName(document.getElementById(this.id + "_run"), "disabled");
    return drawMaze(this.maze);
  };
  return element.mazeReset();
};

// ------ lib/algorithms/eller.js -------
// Generated by CoffeeScript 1.12.4

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Maze.Algorithms.Eller = (function(superClass) {
  extend(Eller, superClass);

  Eller.prototype.IN = 0x1000;

  Eller.prototype.HORIZONTAL = 0;

  Eller.prototype.VERTICAL = 1;

  function Eller(maze, options) {
    Eller.__super__.constructor.apply(this, arguments);
    this.state = new Maze.Algorithms.Eller.State(this.maze.width).populate();
    this.row = 0;
    this.pending = true;
    this.initializeRow();
  }

  Eller.prototype.initializeRow = function() {
    this.column = 0;
    return this.mode = this.HORIZONTAL;
  };

  Eller.prototype.isFinal = function() {
    return this.row + 1 === this.maze.height;
  };

  Eller.prototype.isIn = function(x, y) {
    return this.maze.isValid(x, y) && this.maze.isSet(x, y, this.IN);
  };

  Eller.prototype.isCurrent = function(x, y) {
    return this.column === x && this.row === y;
  };

  Eller.prototype.horizontalStep = function() {
    var oldColumn, ref;
    if (!this.state.isSame(this.column, this.column + 1) && (this.isFinal() || this.rand.nextBoolean())) {
      this.state.merge(this.column, this.column + 1);
      this.maze.carve(this.column, this.row, Maze.Direction.E);
      this.updateAt(this.column, this.row);
      this.maze.carve(this.column + 1, this.row, Maze.Direction.W);
      this.updateAt(this.column + 1, this.row);
    } else if (this.maze.isBlank(this.column, this.row)) {
      this.maze.carve(this.column, this.row, this.IN);
      this.updateAt(this.column, this.row);
    }
    this.column += 1;
    if (this.column > 0) {
      this.updateAt(this.column - 1, this.row);
    }
    this.updateAt(this.column, this.row);
    if (this.column + 1 >= this.maze.width) {
      if (this.maze.isBlank(this.column, this.row)) {
        this.maze.carve(this.column, this.row, this.IN);
        this.updateAt(this.column, this.row);
      }
      if (this.isFinal()) {
        this.pending = false;
        ref = [this.column, null], oldColumn = ref[0], this.column = ref[1];
        return this.updateAt(oldColumn, this.row);
      } else {
        this.mode = this.VERTICAL;
        this.next_state = this.state.next();
        this.verticals = this.computeVerticals();
        return this.eventAt(0, this.row);
      }
    }
  };

  Eller.prototype.computeVerticals = function() {
    var verts;
    verts = [];
    this.state.foreach((function(_this) {
      return function(id, set) {
        var cellsToConnect, countFromThisSet;
        countFromThisSet = 1 + _this.rand.nextInteger(set.length - 1);
        cellsToConnect = _this.rand.randomizeList(set).slice(0, countFromThisSet);
        return verts = verts.concat(cellsToConnect);
      };
    })(this));
    return verts.sort(function(a, b) {
      return a - b;
    });
  };

  Eller.prototype.verticalStep = function() {
    var oldColumn, ref;
    if (this.verticals.length === 0) {
      this.state = this.next_state.populate();
      this.row += 1;
      oldColumn = this.column;
      this.initializeRow();
      this.eventAt(0, this.row);
      this.updateAt(oldColumn, this.row - 1);
      return this.updateAt(this.column, this.row);
    } else {
      ref = [this.column, this.verticals.pop()], oldColumn = ref[0], this.column = ref[1];
      this.updateAt(oldColumn, this.row);
      this.next_state.add(this.column, this.state.setFor(this.column));
      this.maze.carve(this.column, this.row, Maze.Direction.S);
      this.updateAt(this.column, this.row);
      this.maze.carve(this.column, this.row + 1, Maze.Direction.N);
      return this.updateAt(this.column, this.row + 1);
    }
  };

  Eller.prototype.step = function() {
    switch (this.mode) {
      case this.HORIZONTAL:
        this.horizontalStep();
        break;
      case this.VERTICAL:
        this.verticalStep();
    }
    return this.pending;
  };

  return Eller;

})(Maze.Algorithm);

Maze.Algorithms.Eller.State = (function() {
  function State(width, counter) {
    this.width = width;
    this.counter = counter;
    if (this.counter == null) {
      this.counter = 0;
    }
    this.sets = {};
    this.cells = [];
  }

  State.prototype.next = function() {
    return new Maze.Algorithms.Eller.State(this.width, this.counter);
  };

  State.prototype.populate = function() {
    var base, cell, set;
    cell = 0;
    while (cell < this.width) {
      if (!this.cells[cell]) {
        set = (this.counter += 1);
        ((base = this.sets)[set] != null ? base[set] : base[set] = []).push(cell);
        this.cells[cell] = set;
      }
      cell += 1;
    }
    return this;
  };

  State.prototype.merge = function(sink, target) {
    var cell, i, len, ref, sink_set, target_set;
    sink_set = this.cells[sink];
    target_set = this.cells[target];
    this.sets[sink_set] = this.sets[sink_set].concat(this.sets[target_set]);
    ref = this.sets[target_set];
    for (i = 0, len = ref.length; i < len; i++) {
      cell = ref[i];
      this.cells[cell] = sink_set;
    }
    return delete this.sets[target_set];
  };

  State.prototype.isSame = function(a, b) {
    return this.cells[a] === this.cells[b];
  };

  State.prototype.add = function(cell, set) {
    var base;
    this.cells[cell] = set;
    ((base = this.sets)[set] != null ? base[set] : base[set] = []).push(cell);
    return this;
  };

  State.prototype.setFor = function(cell) {
    return this.cells[cell];
  };

  State.prototype.foreach = function(fn) {
    var id, ref, results, set;
    ref = this.sets;
    results = [];
    for (id in ref) {
      set = ref[id];
      results.push(fn(id, set));
    }
    return results;
  };

  return State;

})();

// ------ lib/algorithms/aldous_broder.js -------
// Generated by CoffeeScript 1.12.4

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Maze.Algorithms.AldousBroder = (function(superClass) {
  extend(AldousBroder, superClass);

  AldousBroder.prototype.IN = 0x1000;

  function AldousBroder(maze, options) {
    AldousBroder.__super__.constructor.apply(this, arguments);
    this.state = 0;
    this.remaining = this.maze.width * this.maze.height;
  }

  AldousBroder.prototype.isCurrent = function(x, y) {
    return this.x === x && this.y === y;
  };

  AldousBroder.prototype.startStep = function() {
    this.x = this.rand.nextInteger(this.maze.width);
    this.y = this.rand.nextInteger(this.maze.height);
    this.maze.carve(this.x, this.y, this.IN);
    this.updateAt(this.x, this.y);
    this.remaining--;
    this.state = 1;
    return this.carvedOnLastStep = true;
  };

  AldousBroder.prototype.runStep = function() {
    var carved, dir, i, len, nx, ny, ref, ref1, x, y;
    carved = false;
    if (this.remaining > 0) {
      ref = this.rand.randomDirections();
      for (i = 0, len = ref.length; i < len; i++) {
        dir = ref[i];
        nx = this.x + Maze.Direction.dx[dir];
        ny = this.y + Maze.Direction.dy[dir];
        if (this.maze.isValid(nx, ny)) {
          ref1 = [this.x, this.y, nx, ny], x = ref1[0], y = ref1[1], this.x = ref1[2], this.y = ref1[3];
          if (this.maze.isBlank(nx, ny)) {
            this.maze.carve(x, y, dir);
            this.maze.carve(this.x, this.y, Maze.Direction.opposite[dir]);
            this.remaining--;
            carved = true;
            if (this.remaining === 0) {
              delete this.x;
              delete this.y;
            }
          }
          this.updateAt(x, y);
          this.updateAt(nx, ny);
          break;
        }
      }
    }
    if (carved !== this.carvedOnLastStep) {
      this.eventAt(this.x, this.y);
    }
    this.carvedOnLastStep = carved;
    return this.remaining > 0;
  };

  AldousBroder.prototype.step = function() {
    switch (this.state) {
      case 0:
        this.startStep();
        break;
      case 1:
        this.runStep();
    }
    return this.remaining > 0;
  };

  return AldousBroder;

})(Maze.Algorithm);

// ------ lib/algorithms/backtracker.js -------
// Generated by CoffeeScript 1.12.4

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Maze.Algorithms.RecursiveBacktracker = (function(superClass) {
  extend(RecursiveBacktracker, superClass);

  RecursiveBacktracker.prototype.IN = 0x1000;

  RecursiveBacktracker.prototype.STACK = 0x2000;

  RecursiveBacktracker.prototype.START = 1;

  RecursiveBacktracker.prototype.RUN = 2;

  RecursiveBacktracker.prototype.DONE = 3;

  function RecursiveBacktracker(maze, options) {
    RecursiveBacktracker.__super__.constructor.apply(this, arguments);
    this.state = this.START;
    this.stack = [];
  }

  RecursiveBacktracker.prototype.step = function() {
    switch (this.state) {
      case this.START:
        this.startStep();
        break;
      case this.RUN:
        this.runStep();
    }
    return this.state !== this.DONE;
  };

  RecursiveBacktracker.prototype.startStep = function() {
    var ref, x, y;
    ref = [this.rand.nextInteger(this.maze.width), this.rand.nextInteger(this.maze.height)], x = ref[0], y = ref[1];
    this.maze.carve(x, y, this.IN | this.STACK);
    this.updateAt(x, y);
    this.stack.push({
      x: x,
      y: y,
      dirs: this.rand.randomDirections()
    });
    this.state = this.RUN;
    return this.carvedOnLastStep = true;
  };

  RecursiveBacktracker.prototype.runStep = function() {
    var current, dir, nx, ny;
    while (true) {
      current = this.stack[this.stack.length - 1];
      dir = current.dirs.pop();
      nx = current.x + Maze.Direction.dx[dir];
      ny = current.y + Maze.Direction.dy[dir];
      if (this.maze.isValid(nx, ny)) {
        if (this.maze.isBlank(nx, ny)) {
          this.stack.push({
            x: nx,
            y: ny,
            dirs: this.rand.randomDirections()
          });
          this.maze.carve(current.x, current.y, dir);
          this.updateAt(current.x, current.y);
          this.maze.carve(nx, ny, Maze.Direction.opposite[dir] | this.STACK);
          this.updateAt(nx, ny);
          if (!this.carvedOnLastStep) {
            this.eventAt(nx, ny);
          }
          this.carvedOnLastStep = true;
          break;
        } else if (this.canWeave(dir, nx, ny)) {
          this.performWeave(dir, current.x, current.y, (function(_this) {
            return function(x, y) {
              _this.stack.push({
                x: x,
                y: y,
                dirs: _this.rand.randomDirections()
              });
              if (!_this.carvedOnLastStep) {
                _this.eventAt(x, y);
              }
              return _this.maze.carve(x, y, _this.STACK);
            };
          })(this));
          this.carvedOnLastStep = true;
          break;
        }
      }
      if (current.dirs.length === 0) {
        this.maze.uncarve(current.x, current.y, this.STACK);
        this.updateAt(current.x, current.y);
        if (this.carvedOnLastStep) {
          this.eventAt(current.x, current.y);
        }
        this.stack.pop();
        this.carvedOnLastStep = false;
        break;
      }
    }
    if (this.stack.length === 0) {
      return this.state = this.DONE;
    }
  };

  RecursiveBacktracker.prototype.isStack = function(x, y) {
    return this.maze.isSet(x, y, this.STACK);
  };

  return RecursiveBacktracker;

})(Maze.Algorithm);

// ------ lib/algorithms/binary_tree.js -------
// Generated by CoffeeScript 1.12.4

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Maze.Algorithms.BinaryTree = (function(superClass) {
  extend(BinaryTree, superClass);

  BinaryTree.prototype.IN = 0x1000;

  BinaryTree.prototype.isCurrent = function(x, y) {
    return this.x === x && this.y === y;
  };

  function BinaryTree(maze, options) {
    var ref;
    BinaryTree.__super__.constructor.apply(this, arguments);
    this.x = 0;
    this.y = 0;
    switch ((ref = options.input) != null ? ref : "nw") {
      case "nw":
        this.bias = Maze.Direction.N | Maze.Direction.W;
        break;
      case "ne":
        this.bias = Maze.Direction.N | Maze.Direction.E;
        break;
      case "sw":
        this.bias = Maze.Direction.S | Maze.Direction.W;
        break;
      case "se":
        this.bias = Maze.Direction.S | Maze.Direction.E;
    }
    this.northBias = (this.bias & Maze.Direction.N) !== 0;
    this.southBias = (this.bias & Maze.Direction.S) !== 0;
    this.eastBias = (this.bias & Maze.Direction.E) !== 0;
    this.westBias = (this.bias & Maze.Direction.W) !== 0;
  }

  BinaryTree.prototype.step = function() {
    var direction, dirs, nx, ny, oldX, oldY, ref;
    if (this.y >= this.maze.height) {
      return false;
    }
    dirs = [];
    if (this.northBias && this.y > 0) {
      dirs.push(Maze.Direction.N);
    }
    if (this.southBias && this.y + 1 < this.maze.height) {
      dirs.push(Maze.Direction.S);
    }
    if (this.westBias && this.x > 0) {
      dirs.push(Maze.Direction.W);
    }
    if (this.eastBias && this.x + 1 < this.maze.width) {
      dirs.push(Maze.Direction.E);
    }
    direction = this.rand.randomElement(dirs);
    if (direction) {
      nx = this.x + Maze.Direction.dx[direction];
      ny = this.y + Maze.Direction.dy[direction];
      this.maze.carve(this.x, this.y, direction);
      this.maze.carve(nx, ny, Maze.Direction.opposite[direction]);
      this.updateAt(nx, ny);
    } else {
      this.maze.carve(this.x, this.y, this.IN);
    }
    ref = [this.x, this.y], oldX = ref[0], oldY = ref[1];
    this.x++;
    if (this.x >= this.maze.width) {
      this.x = 0;
      this.y++;
      this.eventAt(this.x, this.y);
    }
    this.updateAt(oldX, oldY);
    this.updateAt(this.x, this.y);
    return this.y < this.maze.height;
  };

  return BinaryTree;

})(Maze.Algorithm);

// ------ lib/algorithms/blobby_division.js -------
// Generated by CoffeeScript 1.12.4

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var BlobbyCell, BlobbyRegion,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

BlobbyCell = (function() {
  function BlobbyCell(row1, col1) {
    this.row = row1;
    this.col = col1;
    this.name = "r" + this.row + "c" + this.col;
  }

  BlobbyCell.prototype.north = function() {
    return "r" + (this.row - 1) + "c" + this.col;
  };

  BlobbyCell.prototype.south = function() {
    return "r" + (this.row + 1) + "c" + this.col;
  };

  BlobbyCell.prototype.east = function() {
    return "r" + this.row + "c" + (this.col + 1);
  };

  BlobbyCell.prototype.west = function() {
    return "r" + this.row + "c" + (this.col - 1);
  };

  return BlobbyCell;

})();

BlobbyRegion = (function() {
  function BlobbyRegion() {
    this.cells = [];
  }

  BlobbyRegion.prototype.addCell = function(cell) {
    this[cell.name] = cell;
    return this.cells.push(cell);
  };

  return BlobbyRegion;

})();

Maze.Algorithms.BlobbyDivision = (function(superClass) {
  extend(BlobbyDivision, superClass);

  BlobbyDivision.prototype.START = 1;

  BlobbyDivision.prototype.PLANT = 2;

  BlobbyDivision.prototype.GROW = 3;

  BlobbyDivision.prototype.WALL = 4;

  function BlobbyDivision(maze, options) {
    var cell, col, i, j, ref, ref1, ref2, ref3, ref4, region, row;
    BlobbyDivision.__super__.constructor.apply(this, arguments);
    this.threshold = (ref = options.threshold) != null ? ref : 4;
    this.growSpeed = (ref1 = options.growSpeed) != null ? ref1 : 5;
    this.wallSpeed = (ref2 = options.wallSpeed) != null ? ref2 : 2;
    this.stack = [];
    region = new BlobbyRegion;
    for (row = i = 0, ref3 = maze.height; 0 <= ref3 ? i < ref3 : i > ref3; row = 0 <= ref3 ? ++i : --i) {
      for (col = j = 0, ref4 = maze.width; 0 <= ref4 ? j < ref4 : j > ref4; col = 0 <= ref4 ? ++j : --j) {
        cell = new BlobbyCell(row, col);
        region.addCell(cell);
        if (row > 0) {
          maze.carve(col, row, Maze.Direction.N);
          maze.carve(col, row - 1, Maze.Direction.S);
        }
        if (col > 0) {
          maze.carve(col, row, Maze.Direction.W);
          maze.carve(col - 1, row, Maze.Direction.E);
        }
      }
    }
    this.stack.push(region);
    this.state = this.START;
  }

  BlobbyDivision.prototype.stateAt = function(col, row) {
    var cell, name, ref, ref1;
    name = "r" + row + "c" + col;
    cell = (ref = this.region) != null ? ref[name] : void 0;
    if (cell) {
      return (ref1 = cell.state) != null ? ref1 : "active";
    } else {
      return "blank";
    }
  };

  BlobbyDivision.prototype.step = function() {
    switch (this.state) {
      case this.START:
        return this.startRegion();
      case this.PLANT:
        return this.plantSeeds();
      case this.GROW:
        return this.growSeeds();
      case this.WALL:
        return this.drawWall();
    }
  };

  BlobbyDivision.prototype.startRegion = function() {
    var cell, i, len, ref;
    delete this.boundary;
    this.region = this.stack.pop();
    if (this.region) {
      ref = this.region.cells;
      for (i = 0, len = ref.length; i < len; i++) {
        cell = ref[i];
        delete cell.state;
      }
      this.highlightRegion(this.region);
      this.state = this.PLANT;
      return true;
    } else {
      return false;
    }
  };

  BlobbyDivision.prototype.plantSeeds = function() {
    var a, b, i, indexes, ref, results;
    indexes = this.rand.randomizeList((function() {
      results = [];
      for (var i = 0, ref = this.region.cells.length; 0 <= ref ? i < ref : i > ref; 0 <= ref ? i++ : i--){ results.push(i); }
      return results;
    }).apply(this));
    this.subregions = {
      a: new BlobbyRegion,
      b: new BlobbyRegion
    };
    a = this.region.cells[indexes[0]];
    b = this.region.cells[indexes[1]];
    a.state = "a";
    b.state = "b";
    this.subregions.a.addCell(a);
    this.subregions.b.addCell(b);
    this.updateAt(a.col, a.row);
    this.updateAt(b.col, b.row);
    this.frontier = [a, b];
    this.state = this.GROW;
    return true;
  };

  BlobbyDivision.prototype.growSeeds = function() {
    var cell, e, growCount, index, list, n, neighbor, s, w;
    growCount = 0;
    while (this.frontier.length > 0 && growCount < this.growSpeed) {
      index = this.rand.nextInteger(this.frontier.length);
      cell = this.frontier[index];
      n = this.region[cell.north()];
      s = this.region[cell.south()];
      e = this.region[cell.east()];
      w = this.region[cell.west()];
      list = [];
      if (n && !n.state) {
        list.push(n);
      }
      if (s && !s.state) {
        list.push(s);
      }
      if (e && !e.state) {
        list.push(e);
      }
      if (w && !w.state) {
        list.push(w);
      }
      if (list.length > 0) {
        neighbor = this.rand.randomElement(list);
        neighbor.state = cell.state;
        this.subregions[cell.state].addCell(neighbor);
        this.frontier.push(neighbor);
        this.updateAt(neighbor.col, neighbor.row);
        growCount += 1;
      } else {
        this.frontier.splice(index, 1);
      }
    }
    this.state = this.frontier.length === 0 ? this.WALL : this.GROW;
    return true;
  };

  BlobbyDivision.prototype.findWall = function() {
    var cell, e, i, len, n, ref, s, w;
    this.boundary = [];
    ref = this.subregions.a.cells;
    for (i = 0, len = ref.length; i < len; i++) {
      cell = ref[i];
      n = this.region[cell.north()];
      s = this.region[cell.south()];
      e = this.region[cell.east()];
      w = this.region[cell.west()];
      if (n && n.state !== cell.state) {
        this.boundary.push({
          from: cell,
          to: n,
          dir: Maze.Direction.N
        });
      }
      if (s && s.state !== cell.state) {
        this.boundary.push({
          from: cell,
          to: s,
          dir: Maze.Direction.S
        });
      }
      if (e && e.state !== cell.state) {
        this.boundary.push({
          from: cell,
          to: e,
          dir: Maze.Direction.E
        });
      }
      if (w && w.state !== cell.state) {
        this.boundary.push({
          from: cell,
          to: w,
          dir: Maze.Direction.W
        });
      }
    }
    return this.rand.removeRandomElement(this.boundary);
  };

  BlobbyDivision.prototype.drawWall = function() {
    var cell, i, j, k, len, len1, len2, ref, ref1, ref2, wall, wallCount;
    if (!this.boundary) {
      this.findWall();
    }
    wallCount = 0;
    while (this.boundary.length > 0 && wallCount < this.wallSpeed) {
      wall = this.rand.removeRandomElement(this.boundary);
      this.maze.uncarve(wall.from.col, wall.from.row, wall.dir);
      this.maze.uncarve(wall.to.col, wall.to.row, Maze.Direction.opposite[wall.dir]);
      this.updateAt(wall.from.col, wall.from.row);
      wallCount += 1;
    }
    if (this.boundary.length === 0) {
      ref = this.region.cells;
      for (i = 0, len = ref.length; i < len; i++) {
        cell = ref[i];
        cell.state = "blank";
      }
      if (this.subregions.a.cells.length >= this.threshold || (this.subregions.a.cells.length > 4 && this.rand.nextInteger() % 10 < 5)) {
        this.stack.push(this.subregions.a);
      } else {
        ref1 = this.subregions.a.cells;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          cell = ref1[j];
          cell.state = "in";
        }
      }
      if (this.subregions.b.cells.length >= this.threshold || (this.subregions.b.cells.length > 4 && this.rand.nextInteger() % 10 < 5)) {
        this.stack.push(this.subregions.b);
      } else {
        ref2 = this.subregions.b.cells;
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          cell = ref2[k];
          cell.state = "in";
        }
      }
      this.highlightRegion(this.subregions.a);
      this.highlightRegion(this.subregions.b);
      this.state = this.START;
    }
    return true;
  };

  BlobbyDivision.prototype.highlightRegion = function(region) {
    var cell, i, len, ref, results;
    ref = region.cells;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      cell = ref[i];
      results.push(this.updateAt(cell.col, cell.row));
    }
    return results;
  };

  return BlobbyDivision;

})(Maze.Algorithm);

// ------ lib/algorithms/division.js -------
// Generated by CoffeeScript 1.12.4

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Maze.Algorithms.RecursiveDivision = (function(superClass) {
  extend(RecursiveDivision, superClass);

  RecursiveDivision.prototype.CHOOSE_REGION = 0;

  RecursiveDivision.prototype.MAKE_WALL = 1;

  RecursiveDivision.prototype.MAKE_PASSAGE = 2;

  RecursiveDivision.prototype.HORIZONTAL = 1;

  RecursiveDivision.prototype.VERTICAL = 2;

  RecursiveDivision.prototype.isCurrent = function(x, y) {
    return (this.region != null) && (this.region.x <= x && x < this.region.x + this.region.width) && (this.region.y <= y && y < this.region.y + this.region.height);
  };

  function RecursiveDivision(maze, options) {
    RecursiveDivision.__super__.constructor.apply(this, arguments);
    this.stack = [
      {
        x: 0,
        y: 0,
        width: this.maze.width,
        height: this.maze.height
      }
    ];
    this.state = this.CHOOSE_REGION;
  }

  RecursiveDivision.prototype.chooseOrientation = function(width, height) {
    if (width < height) {
      return this.HORIZONTAL;
    } else if (height < width) {
      return this.VERTICAL;
    } else if (this.rand.nextBoolean()) {
      return this.HORIZONTAL;
    } else {
      return this.VERTICAL;
    }
  };

  RecursiveDivision.prototype.updateRegion = function(region) {
    var i, ref, results, x, y;
    results = [];
    for (y = i = 0, ref = region.height; 0 <= ref ? i < ref : i > ref; y = 0 <= ref ? ++i : --i) {
      results.push((function() {
        var j, ref1, results1;
        results1 = [];
        for (x = j = 0, ref1 = region.width; 0 <= ref1 ? j < ref1 : j > ref1; x = 0 <= ref1 ? ++j : --j) {
          results1.push(this.updateAt(region.x + x, region.y + y));
        }
        return results1;
      }).call(this));
    }
    return results;
  };

  RecursiveDivision.prototype.step = function() {
    switch (this.state) {
      case this.CHOOSE_REGION:
        return this.chooseRegion();
      case this.MAKE_WALL:
        return this.makeWall();
      case this.MAKE_PASSAGE:
        return this.makePassage();
    }
  };

  RecursiveDivision.prototype.chooseRegion = function() {
    var priorRegion, ref;
    ref = [this.region, this.stack.pop()], priorRegion = ref[0], this.region = ref[1];
    if (priorRegion) {
      this.updateRegion(priorRegion);
    }
    if (this.region) {
      this.updateRegion(this.region);
      this.state = this.MAKE_WALL;
      return true;
    } else {
      return false;
    }
  };

  RecursiveDivision.prototype.makeWall = function() {
    var dx, dy, length, nx, ny, ref, x, y;
    this.horizontal = this.chooseOrientation(this.region.width, this.region.height) === this.HORIZONTAL;
    this.wx = this.region.x + (this.horizontal ? 0 : this.rand.nextInteger(this.region.width - 2));
    this.wy = this.region.y + (this.horizontal ? this.rand.nextInteger(this.region.height - 2) : 0);
    dx = this.horizontal ? 1 : 0;
    dy = this.horizontal ? 0 : 1;
    length = this.horizontal ? this.region.width : this.region.height;
    this.dir = this.horizontal ? Maze.Direction.S : Maze.Direction.E;
    this.odir = Maze.Direction.opposite[this.dir];
    ref = [this.wx, this.wy], x = ref[0], y = ref[1];
    while (length > 0) {
      this.maze.carve(x, y, this.dir);
      this.updateAt(x, y);
      nx = x + Maze.Direction.dx[this.dir];
      ny = y + Maze.Direction.dy[this.dir];
      this.maze.carve(nx, ny, this.odir);
      this.updateAt(nx, ny);
      x += dx;
      y += dy;
      length -= 1;
    }
    this.state = this.MAKE_PASSAGE;
    return true;
  };

  RecursiveDivision.prototype.makePassage = function() {
    var height, nx, ny, px, py, width, x, y;
    px = this.wx + (this.horizontal ? this.rand.nextInteger(this.region.width) : 0);
    py = this.wy + (this.horizontal ? 0 : this.rand.nextInteger(this.region.height));
    this.maze.uncarve(px, py, this.dir);
    this.updateAt(px, py);
    nx = px + Maze.Direction.dx[this.dir];
    ny = py + Maze.Direction.dy[this.dir];
    this.maze.uncarve(nx, ny, this.odir);
    this.updateAt(nx, ny);
    width = this.horizontal ? this.region.width : this.wx - this.region.x + 1;
    height = this.horizontal ? this.wy - this.region.y + 1 : this.region.height;
    if (width >= 2 && height >= 2) {
      this.stack.push({
        x: this.region.x,
        y: this.region.y,
        width: width,
        height: height
      });
    }
    x = this.horizontal ? this.region.x : this.wx + 1;
    y = this.horizontal ? this.wy + 1 : this.region.y;
    width = this.horizontal ? this.region.width : this.region.x + this.region.width - this.wx - 1;
    height = this.horizontal ? this.region.y + this.region.height - this.wy - 1 : this.region.height;
    if (width >= 2 && height >= 2) {
      this.stack.push({
        x: x,
        y: y,
        width: width,
        height: height
      });
    }
    this.state = this.CHOOSE_REGION;
    return true;
  };

  return RecursiveDivision;

})(Maze.Algorithm);

// ------ lib/algorithms/sidewinder.js -------
// Generated by CoffeeScript 1.12.4

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Maze.Algorithms.Sidewinder = (function(superClass) {
  extend(Sidewinder, superClass);

  Sidewinder.prototype.IN = 0x1000;

  Sidewinder.prototype.isCurrent = function(x, y) {
    return this.x === x && this.y === y;
  };

  function Sidewinder(maze, options) {
    Sidewinder.__super__.constructor.apply(this, arguments);
    this.x = 0;
    this.y = 0;
    this.runStart = 0;
    this.state = 0;
  }

  Sidewinder.prototype.step = function() {
    var cell, oldX, oldY, ref;
    if (this.y >= this.maze.height) {
      return false;
    }
    if (this.y > 0 && (this.x + 1 >= this.maze.width || this.rand.nextBoolean())) {
      cell = this.runStart + this.rand.nextInteger(this.x - this.runStart + 1);
      this.maze.carve(cell, this.y, Maze.Direction.N);
      this.maze.carve(cell, this.y - 1, Maze.Direction.S);
      this.updateAt(cell, this.y);
      this.updateAt(cell, this.y - 1);
      if (this.x - this.runStart > 0) {
        this.eventAt(this.x, this.y);
      }
      this.runStart = this.x + 1;
    } else if (this.x + 1 < this.maze.width) {
      this.maze.carve(this.x, this.y, Maze.Direction.E);
      this.maze.carve(this.x + 1, this.y, Maze.Direction.W);
      this.updateAt(this.x, this.y);
      this.updateAt(this.x + 1, this.y);
    } else {
      this.maze.carve(this.x, this.y, this.IN);
      this.updateAt(this.x, this.y);
    }
    ref = [this.x, this.y], oldX = ref[0], oldY = ref[1];
    this.x++;
    if (this.x >= this.maze.width) {
      this.x = 0;
      this.runStart = 0;
      this.y++;
    }
    this.updateAt(oldX, oldY);
    this.updateAt(this.x, this.y);
    return this.y < this.maze.height;
  };

  return Sidewinder;

})(Maze.Algorithm);

// ------ lib/algorithms/growing_tree.js -------
// Generated by CoffeeScript 1.12.4

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Maze.Algorithms.GrowingTree = (function(superClass) {
  extend(GrowingTree, superClass);

  GrowingTree.prototype.QUEUE = 0x1000;

  function GrowingTree(maze, options) {
    var ref;
    GrowingTree.__super__.constructor.apply(this, arguments);
    this.cells = [];
    this.state = 0;
    this.script = new Maze.Algorithms.GrowingTree.Script((ref = options.input) != null ? ref : "random", this.rand);
  }

  GrowingTree.prototype.inQueue = function(x, y) {
    return this.maze.isSet(x, y, this.QUEUE);
  };

  GrowingTree.prototype.enqueue = function(x, y) {
    this.maze.carve(x, y, this.QUEUE);
    return this.cells.push({
      x: x,
      y: y
    });
  };

  GrowingTree.prototype.nextCell = function() {
    return this.script.nextIndex(this.cells.length);
  };

  GrowingTree.prototype.startStep = function() {
    var ref, x, y;
    ref = [this.rand.nextInteger(this.maze.width), this.rand.nextInteger(this.maze.height)], x = ref[0], y = ref[1];
    this.enqueue(x, y);
    this.updateAt(x, y);
    return this.state = 1;
  };

  GrowingTree.prototype.runStep = function() {
    var cell, direction, i, index, len, nx, ny, ref;
    index = this.nextCell();
    cell = this.cells[index];
    ref = this.rand.randomDirections();
    for (i = 0, len = ref.length; i < len; i++) {
      direction = ref[i];
      nx = cell.x + Maze.Direction.dx[direction];
      ny = cell.y + Maze.Direction.dy[direction];
      if (this.maze.isValid(nx, ny)) {
        if (this.maze.isBlank(nx, ny)) {
          this.maze.carve(cell.x, cell.y, direction);
          this.maze.carve(nx, ny, Maze.Direction.opposite[direction]);
          this.enqueue(nx, ny);
          this.updateAt(cell.x, cell.y);
          this.updateAt(nx, ny);
          return;
        } else if (this.canWeave(direction, nx, ny)) {
          this.performWeave(direction, cell.x, cell.y, (function(_this) {
            return function(toX, toY) {
              return _this.enqueue(toX, toY);
            };
          })(this));
          return;
        }
      }
    }
    this.cells.splice(index, 1);
    this.maze.uncarve(cell.x, cell.y, this.QUEUE);
    return this.updateAt(cell.x, cell.y);
  };

  GrowingTree.prototype.step = function() {
    switch (this.state) {
      case 0:
        this.startStep();
        break;
      case 1:
        this.runStep();
    }
    return this.cells.length > 0;
  };

  return GrowingTree;

})(Maze.Algorithm);

Maze.Algorithms.GrowingTree.Script = (function() {
  function Script(input, rand) {
    var command, name, part, parts, totalWeight, weight;
    this.rand = rand;
    this.commands = (function() {
      var i, len, ref, results;
      ref = input.split(/;|\r?\n/);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        command = ref[i];
        totalWeight = 0;
        parts = (function() {
          var j, len1, ref1, ref2, results1;
          ref1 = command.split(/,/);
          results1 = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            part = ref1[j];
            ref2 = part.split(/:/), name = ref2[0], weight = ref2[1];
            totalWeight += parseInt(weight != null ? weight : 100);
            results1.push({
              name: name.replace(/\s/, ""),
              weight: totalWeight
            });
          }
          return results1;
        })();
        results.push({
          total: totalWeight,
          parts: parts
        });
      }
      return results;
    })();
    this.current = 0;
  }

  Script.prototype.nextIndex = function(ceil) {
    var command, i, len, part, ref, target;
    command = this.commands[this.current];
    this.current = (this.current + 1) % this.commands.length;
    target = this.rand.nextInteger(command.total);
    ref = command.parts;
    for (i = 0, len = ref.length; i < len; i++) {
      part = ref[i];
      if (target < part.weight) {
        switch (part.name) {
          case 'random':
            return this.rand.nextInteger(ceil);
          case 'newest':
            return ceil - 1;
          case 'middle':
            return Math.floor(ceil / 2);
          case 'oldest':
            return 0;
          default:
            throw "invalid weight key `" + part.name + "'";
        }
      }
    }
  };

  return Script;

})();

// ------ lib/algorithms/houston.js -------
// Generated by CoffeeScript 1.12.4

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Maze.Algorithms.Houston = (function(superClass) {
  extend(Houston, superClass);

  function Houston(maze, options) {
    Houston.__super__.constructor.apply(this, arguments);
    this.options = options;
    this.threshold = 2 * this.maze.width * this.maze.height / 3;
  }

  Houston.prototype.isCurrent = function(x, y) {
    return this.worker.isCurrent(x, y);
  };

  Houston.prototype.isVisited = function(x, y) {
    return this.worker.isVisited(x, y);
  };

  Houston.prototype.step = function() {
    var ref, wilsons, x, y;
    if (this.worker == null) {
      this.worker = new Maze.Algorithms.AldousBroder(this.maze, this.options);
      this.worker.onUpdate(this.updateCallback);
      this.worker.onEvent(this.eventCallback);
    }
    if (this.worker.remaining < this.threshold) {
      ref = [this.worker.x, this.worker.y], x = ref[0], y = ref[1];
      delete this.worker.x;
      delete this.worker.y;
      this.updateAt(x, y);
      this.eventAt(x, y);
      wilsons = new Maze.Algorithms.Wilson(this.maze, this.options);
      wilsons.onUpdate(this.updateCallback);
      wilsons.onEvent(this.eventCallback);
      wilsons.state = 1;
      wilsons.remaining = this.worker.remaining;
      this.worker = wilsons;
      this.step = function() {
        return this.worker.step();
      };
    }
    return this.worker.step();
  };

  return Houston;

})(Maze.Algorithm);

// ------ lib/algorithms/hunt_and_kill.js -------
// Generated by CoffeeScript 1.12.4

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Maze.Algorithms.HuntAndKill = (function(superClass) {
  extend(HuntAndKill, superClass);

  HuntAndKill.prototype.IN = 0x1000;

  function HuntAndKill(maze, options) {
    HuntAndKill.__super__.constructor.apply(this, arguments);
    this.state = 0;
  }

  HuntAndKill.prototype.isCurrent = function(x, y) {
    var ref;
    return ((ref = this.x) != null ? ref : x) === x && this.y === y;
  };

  HuntAndKill.prototype.isWalking = function() {
    return this.state === 1;
  };

  HuntAndKill.prototype.isHunting = function() {
    return this.state === 2;
  };

  HuntAndKill.prototype.callbackRow = function(y) {
    var i, ref, results, x;
    results = [];
    for (x = i = 0, ref = this.maze.width; 0 <= ref ? i < ref : i > ref; x = 0 <= ref ? ++i : --i) {
      results.push(this.updateAt(x, y));
    }
    return results;
  };

  HuntAndKill.prototype.startStep = function() {
    this.x = this.rand.nextInteger(this.maze.width);
    this.y = this.rand.nextInteger(this.maze.height);
    this.maze.carve(this.x, this.y, this.IN);
    this.updateAt(this.x, this.y);
    return this.state = 1;
  };

  HuntAndKill.prototype.walkStep = function() {
    var direction, i, len, nx, ny, ref, ref1, ref2, x, y;
    ref = this.rand.randomDirections();
    for (i = 0, len = ref.length; i < len; i++) {
      direction = ref[i];
      nx = this.x + Maze.Direction.dx[direction];
      ny = this.y + Maze.Direction.dy[direction];
      if (this.maze.isValid(nx, ny)) {
        if (this.maze.isBlank(nx, ny)) {
          ref1 = [this.x, this.y, nx, ny], x = ref1[0], y = ref1[1], this.x = ref1[2], this.y = ref1[3];
          this.maze.carve(x, y, direction);
          this.maze.carve(nx, ny, Maze.Direction.opposite[direction]);
          this.updateAt(x, y);
          this.updateAt(nx, ny);
          return;
        } else if (this.canWeave(direction, nx, ny)) {
          this.performWeave(direction, this.x, this.y, (function(_this) {
            return function(x, y) {
              var ref2;
              return ref2 = [_this.x, _this.y, x, y], x = ref2[0], y = ref2[1], _this.x = ref2[2], _this.y = ref2[3], ref2;
            };
          })(this));
          return;
        }
      }
    }
    ref2 = [this.x, this.y], x = ref2[0], y = ref2[1];
    delete this.x;
    delete this.y;
    this.updateAt(x, y);
    this.eventAt(x, y);
    this.y = 0;
    this.state = 2;
    return this.callbackRow(0);
  };

  HuntAndKill.prototype.huntStep = function() {
    var direction, i, neighbors, nx, ny, ref, x;
    for (x = i = 0, ref = this.maze.width; 0 <= ref ? i < ref : i > ref; x = 0 <= ref ? ++i : --i) {
      if (this.maze.isBlank(x, this.y)) {
        neighbors = [];
        if (this.y > 0 && !this.maze.isBlank(x, this.y - 1)) {
          neighbors.push(Maze.Direction.N);
        }
        if (x > 0 && !this.maze.isBlank(x - 1, this.y)) {
          neighbors.push(Maze.Direction.W);
        }
        if (this.y + 1 < this.maze.height && !this.maze.isBlank(x, this.y + 1)) {
          neighbors.push(Maze.Direction.S);
        }
        if (x + 1 < this.maze.width && !this.maze.isBlank(x + 1, this.y)) {
          neighbors.push(Maze.Direction.E);
        }
        direction = this.rand.randomElement(neighbors);
        if (direction) {
          this.x = x;
          nx = this.x + Maze.Direction.dx[direction];
          ny = this.y + Maze.Direction.dy[direction];
          this.maze.carve(this.x, this.y, direction);
          this.maze.carve(nx, ny, Maze.Direction.opposite[direction]);
          this.state = 1;
          this.updateAt(nx, ny);
          this.callbackRow(this.y);
          this.eventAt(nx, ny);
          return;
        }
      }
    }
    this.y++;
    this.callbackRow(this.y - 1);
    if (this.y >= this.maze.height) {
      this.state = 3;
      delete this.x;
      return delete this.y;
    } else {
      return this.callbackRow(this.y);
    }
  };

  HuntAndKill.prototype.step = function() {
    switch (this.state) {
      case 0:
        this.startStep();
        break;
      case 1:
        this.walkStep();
        break;
      case 2:
        this.huntStep();
    }
    return this.state !== 3;
  };

  return HuntAndKill;

})(Maze.Algorithm);

// ------ lib/algorithms/kruskal.js -------
// Generated by CoffeeScript 1.12.4

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Maze.Algorithms.Kruskal = (function(superClass) {
  extend(Kruskal, superClass);

  Kruskal.prototype.WEAVE = 1;

  Kruskal.prototype.JOIN = 2;

  function Kruskal(maze, options) {
    var i, j, ref, ref1, ref2, ref3, x, y;
    Kruskal.__super__.constructor.apply(this, arguments);
    this.sets = [];
    this.edges = [];
    for (y = i = 0, ref = this.maze.height; 0 <= ref ? i < ref : i > ref; y = 0 <= ref ? ++i : --i) {
      this.sets.push([]);
      for (x = j = 0, ref1 = this.maze.width; 0 <= ref1 ? j < ref1 : j > ref1; x = 0 <= ref1 ? ++j : --j) {
        this.sets[y].push(new Maze.Algorithms.Kruskal.Tree());
        if (y > 0) {
          this.edges.push({
            x: x,
            y: y,
            direction: Maze.Direction.N
          });
        }
        if (x > 0) {
          this.edges.push({
            x: x,
            y: y,
            direction: Maze.Direction.W
          });
        }
      }
    }
    this.rand.randomizeList(this.edges);
    this.weaveMode = (ref2 = options.weaveMode) != null ? ref2 : "onePhase";
    if (typeof this.weaveMode === "function") {
      this.weaveMode = this.weaveMode();
    }
    this.weaveDensity = (ref3 = options.weaveDensity) != null ? ref3 : 80;
    if (typeof this.weaveDensity === "function") {
      this.weaveDensity = this.weaveDensity();
    }
    this.state = (this.maze.isWeave != null) && this.weaveMode === "twoPhase" ? this.WEAVE : this.JOIN;
  }

  Kruskal.prototype.connect = function(x1, y1, x2, y2, direction) {
    this.sets[y1][x1].connect(this.sets[y2][x2]);
    this.maze.carve(x1, y1, direction);
    this.updateAt(x1, y1);
    this.maze.carve(x2, y2, Maze.Direction.opposite[direction]);
    return this.updateAt(x2, y2);
  };

  Kruskal.prototype.weaveStep = function() {
    var edge, ex, ey, i, len, newEdges, nx, ny, ref, ref1, ref2, ref3, ref4, results, safe, sx, sy, wx, wy;
    if (this.x == null) {
      this.y = 1;
      this.x = 1;
    }
    results = [];
    while (this.state === this.WEAVE) {
      if (this.maze.isBlank(this.x, this.y) && this.rand.nextInteger(100) < this.weaveDensity) {
        ref = [this.x, this.y - 1], nx = ref[0], ny = ref[1];
        ref1 = [this.x - 1, this.y], wx = ref1[0], wy = ref1[1];
        ref2 = [this.x + 1, this.y], ex = ref2[0], ey = ref2[1];
        ref3 = [this.x, this.y + 1], sx = ref3[0], sy = ref3[1];
        safe = !this.sets[ny][nx].isConnectedTo(this.sets[sy][sx]) && !this.sets[wy][wx].isConnectedTo(this.sets[ey][ex]);
        if (safe) {
          this.sets[ny][nx].connect(this.sets[sy][sx]);
          this.sets[wy][wx].connect(this.sets[ey][ex]);
          if (this.rand.nextBoolean()) {
            this.maze.carve(this.x, this.y, Maze.Direction.E | Maze.Direction.W | Maze.Direction.U);
          } else {
            this.maze.carve(this.x, this.y, Maze.Direction.N | Maze.Direction.S | Maze.Direction.U);
          }
          this.maze.carve(nx, ny, Maze.Direction.S);
          this.maze.carve(wx, wy, Maze.Direction.E);
          this.maze.carve(ex, ey, Maze.Direction.W);
          this.maze.carve(sx, sy, Maze.Direction.N);
          this.updateAt(this.x, this.y);
          this.updateAt(nx, ny);
          this.updateAt(wx, wy);
          this.updateAt(ex, ey);
          this.updateAt(sx, sy);
          newEdges = [];
          ref4 = this.edges;
          for (i = 0, len = ref4.length; i < len; i++) {
            edge = ref4[i];
            if ((edge.x === this.x && edge.y === this.y) || (edge.x === ex && edge.y === ey && edge.direction === Maze.Direction.W) || (edge.x === sx && edge.y === sy && edge.direction === Maze.Direction.N)) {
              continue;
            }
            newEdges.push(edge);
          }
          this.edges = newEdges;
          break;
        }
      }
      this.x++;
      if (this.x >= this.maze.width - 1) {
        this.x = 1;
        this.y++;
        if (this.y >= this.maze.height - 1) {
          this.state = this.JOIN;
          results.push(this.eventAt(this.x, this.y));
        } else {
          results.push(void 0);
        }
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Kruskal.prototype.joinStep = function() {
    var edge, edge2, i, index, nx, nx2, ny, ny2, ref, results, set1, set2, set3;
    results = [];
    while (this.edges.length > 0) {
      edge = this.edges.pop();
      nx = edge.x + Maze.Direction.dx[edge.direction];
      ny = edge.y + Maze.Direction.dy[edge.direction];
      set1 = this.sets[edge.y][edge.x];
      set2 = this.sets[ny][nx];
      if ((this.maze.isWeave != null) && this.weaveMode === "onePhase" && this.maze.isPerpendicular(nx, ny, edge.direction)) {
        nx2 = nx + Maze.Direction.dx[edge.direction];
        ny2 = ny + Maze.Direction.dy[edge.direction];
        set3 = null;
        for (index = i = 0, ref = this.edges.length; 0 <= ref ? i < ref : i > ref; index = 0 <= ref ? ++i : --i) {
          edge2 = this.edges[index];
          if (edge2.x === nx && edge2.y === ny && edge2.direction === edge.direction) {
            this.edges.splice(index, 1);
            set3 = this.sets[ny2][nx2];
            break;
          }
        }
        if (set3 && !set1.isConnectedTo(set3)) {
          this.connect(edge.x, edge.y, nx2, ny2, edge.direction);
          this.performThruWeave(nx, ny);
          this.updateAt(nx, ny);
          break;
        } else if (!set1.isConnectedTo(set2)) {
          this.connect(edge.x, edge.y, nx, ny, edge.direction);
          break;
        } else {
          results.push(void 0);
        }
      } else if (!set1.isConnectedTo(set2)) {
        this.connect(edge.x, edge.y, nx, ny, edge.direction);
        break;
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Kruskal.prototype.step = function() {
    switch (this.state) {
      case this.WEAVE:
        this.weaveStep();
        break;
      case this.JOIN:
        this.joinStep();
    }
    return this.edges.length > 0;
  };

  return Kruskal;

})(Maze.Algorithm);

Maze.Algorithms.Kruskal.Tree = (function() {
  function Tree() {
    this.up = null;
  }

  Tree.prototype.root = function() {
    if (this.up) {
      return this.up.root();
    } else {
      return this;
    }
  };

  Tree.prototype.isConnectedTo = function(tree) {
    return this.root() === tree.root();
  };

  Tree.prototype.connect = function(tree) {
    return tree.root().up = this;
  };

  return Tree;

})();

// ------ lib/algorithms/parallel_backtracker.js -------
// Generated by CoffeeScript 1.12.4

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Maze.Algorithms.ParallelBacktracker = (function(superClass) {
  extend(ParallelBacktracker, superClass);

  ParallelBacktracker.prototype.IN = 0x1000;

  ParallelBacktracker.prototype.STACK = 0x2000;

  ParallelBacktracker.prototype.START = 1;

  ParallelBacktracker.prototype.RUN = 2;

  ParallelBacktracker.prototype.DONE = 3;

  function ParallelBacktracker(maze, options) {
    var cell, east, i, j, k, name, north, ref, ref1, south, west, x, y;
    ParallelBacktracker.__super__.constructor.apply(this, arguments);
    this.cells = [];
    this.sets = {};
    for (x = j = 0, ref = maze.height; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
      for (y = k = 0, ref1 = maze.width; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
        name = "c" + x + "r" + y;
        north = "c" + x + "r" + (y - 1);
        south = "c" + x + "r" + (y + 1);
        east = "c" + (x + 1) + "r" + y;
        west = "c" + (x - 1) + "r" + y;
        cell = {
          x: x,
          y: y,
          name: name,
          north: north,
          south: south,
          west: west,
          east: east,
          dirs: this.rand.randomDirections()
        };
        this.cells.push(cell);
        this.cells[name] = cell;
      }
    }
    this.state = this.START;
    this.stacks = (function() {
      var l, ref2, ref3, results;
      results = [];
      for (i = l = 1, ref2 = (ref3 = options.input) != null ? ref3 : 2; 1 <= ref2 ? l <= ref2 : l >= ref2; i = 1 <= ref2 ? ++l : --l) {
        results.push([]);
      }
      return results;
    })();
  }

  ParallelBacktracker.prototype.step = function() {
    switch (this.state) {
      case this.START:
        this.startStep();
        break;
      case this.RUN:
        this.runStep();
    }
    return this.state !== this.DONE;
  };

  ParallelBacktracker.prototype.startStep = function() {
    var cell, i, indexes, j, k, ref, ref1, results;
    indexes = this.rand.randomizeList((function() {
      results = [];
      for (var j = 0, ref = this.cells.length; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this));
    for (i = k = 0, ref1 = this.stacks.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
      cell = this.cells[indexes[i]];
      this.maze.carve(cell.x, cell.y, this.IN | this.STACK);
      this.updateAt(cell.x, cell.y);
      cell.set = "s" + i;
      this.stacks[i] = [cell];
      this.sets[cell.set] = [cell];
    }
    return this.state = this.RUN;
  };

  ParallelBacktracker.prototype.cellAt = function(x, y) {
    return this.cells["c" + x + "r" + y];
  };

  ParallelBacktracker.prototype.runStep = function() {
    var activeStacks, base, cell, current, dir, i, j, k, l, len, len1, n, neighbor, nx, ny, oldSet, ref, ref1, ref2, results, stack;
    activeStacks = 0;
    for (i = j = 0, ref = this.stacks.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      stack = this.stacks[i];
      if (stack.length === 0) {
        continue;
      }
      activeStacks += 1;
      while (true) {
        current = stack[stack.length - 1];
        dir = current.dirs.pop();
        nx = current.x + Maze.Direction.dx[dir];
        ny = current.y + Maze.Direction.dy[dir];
        if (this.maze.isValid(nx, ny)) {
          neighbor = this.cellAt(nx, ny);
          if ((neighbor != null) && current.set !== neighbor.set) {
            stack.push(neighbor);
            this.maze.carve(current.x, current.y, dir);
            this.maze.carve(neighbor.x, neighbor.y, Maze.Direction.opposite[dir] | this.STACK);
            this.updateAt(current.x, current.y);
            oldSet = neighbor.set;
            if ((base = this.sets)[oldSet] == null) {
              base[oldSet] = [neighbor];
            }
            ref1 = this.sets[oldSet];
            for (k = 0, len = ref1.length; k < len; k++) {
              n = ref1[k];
              n.set = current.set;
              this.sets[current.set].push(n);
              this.updateAt(n.x, n.y);
            }
            delete this.sets[oldSet];
            break;
          }
        }
        if (current.dirs.length === 0) {
          this.maze.uncarve(current.x, current.y, this.STACK);
          this.updateAt(current.x, current.y);
          stack.pop();
          break;
        }
      }
    }
    if (activeStacks === 0) {
      this.state = this.DONE;
      ref2 = this.cells;
      results = [];
      for (l = 0, len1 = ref2.length; l < len1; l++) {
        cell = ref2[l];
        cell.set = "final";
        results.push(this.updateAt(cell.x, cell.y));
      }
      return results;
    }
  };

  ParallelBacktracker.prototype.isStack = function(x, y) {
    return this.maze.isSet(x, y, this.STACK);
  };

  return ParallelBacktracker;

})(Maze.Algorithm);

// ------ lib/algorithms/prim.js -------
// Generated by CoffeeScript 1.12.4

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Maze.Algorithms.Prim = (function(superClass) {
  extend(Prim, superClass);

  Prim.prototype.IN = 0x1000;

  Prim.prototype.FRONTIER = 0x2000;

  Prim.prototype.START = 1;

  Prim.prototype.EXPAND = 2;

  Prim.prototype.DONE = 3;

  function Prim(maze, options) {
    Prim.__super__.constructor.apply(this, arguments);
    this.frontierCells = [];
    this.state = this.START;
  }

  Prim.prototype.isOutside = function(x, y) {
    return this.maze.isValid(x, y) && this.maze.isBlank(x, y);
  };

  Prim.prototype.isInside = function(x, y) {
    return this.maze.isValid(x, y) && this.maze.isSet(x, y, this.IN);
  };

  Prim.prototype.isFrontier = function(x, y) {
    return this.maze.isValid(x, y) && this.maze.isSet(x, y, this.FRONTIER);
  };

  Prim.prototype.addFrontier = function(x, y) {
    if (this.isOutside(x, y)) {
      this.frontierCells.push({
        x: x,
        y: y
      });
      this.maze.carve(x, y, this.FRONTIER);
      return this.updateAt(x, y);
    }
  };

  Prim.prototype.markCell = function(x, y) {
    this.maze.carve(x, y, this.IN);
    this.maze.uncarve(x, y, this.FRONTIER);
    this.updateAt(x, y);
    this.addFrontier(x - 1, y);
    this.addFrontier(x + 1, y);
    this.addFrontier(x, y - 1);
    return this.addFrontier(x, y + 1);
  };

  Prim.prototype.findNeighborsOf = function(x, y) {
    var neighbors;
    neighbors = [];
    if (this.isInside(x - 1, y)) {
      neighbors.push(Maze.Direction.W);
    }
    if (this.isInside(x + 1, y)) {
      neighbors.push(Maze.Direction.E);
    }
    if (this.isInside(x, y - 1)) {
      neighbors.push(Maze.Direction.N);
    }
    if (this.isInside(x, y + 1)) {
      neighbors.push(Maze.Direction.S);
    }
    return neighbors;
  };

  Prim.prototype.startStep = function() {
    this.markCell(this.rand.nextInteger(this.maze.width), this.rand.nextInteger(this.maze.height));
    return this.state = this.EXPAND;
  };

  Prim.prototype.expandStep = function() {
    var cell, direction, nx, nx2, ny, ny2, ref;
    cell = this.rand.removeRandomElement(this.frontierCells);
    direction = this.rand.randomElement(this.findNeighborsOf(cell.x, cell.y));
    nx = cell.x + Maze.Direction.dx[direction];
    ny = cell.y + Maze.Direction.dy[direction];
    if (this.maze.isWeave && this.maze.isPerpendicular(nx, ny, direction)) {
      nx2 = nx + Maze.Direction.dx[direction];
      ny2 = ny + Maze.Direction.dy[direction];
      if (this.isInside(nx2, ny2)) {
        this.performThruWeave(nx, ny);
        this.updateAt(nx, ny);
        ref = [nx2, ny2], nx = ref[0], ny = ref[1];
      }
    }
    this.maze.carve(nx, ny, Maze.Direction.opposite[direction]);
    this.updateAt(nx, ny);
    this.maze.carve(cell.x, cell.y, direction);
    this.markCell(cell.x, cell.y);
    if (this.frontierCells.length === 0) {
      return this.state = this.DONE;
    }
  };

  Prim.prototype.step = function() {
    switch (this.state) {
      case this.START:
        this.startStep();
        break;
      case this.EXPAND:
        this.expandStep();
    }
    return this.state !== this.DONE;
  };

  return Prim;

})(Maze.Algorithm);

// ------ lib/algorithms/wilson.js -------
// Generated by CoffeeScript 1.12.4

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Maze.Algorithms.Wilson = (function(superClass) {
  extend(Wilson, superClass);

  Wilson.prototype.IN = 0x1000;

  function Wilson(maze, options) {
    Wilson.__super__.constructor.apply(this, arguments);
    this.state = 0;
    this.remaining = this.maze.width * this.maze.height;
    this.visits = {};
  }

  Wilson.prototype.isCurrent = function(x, y) {
    return this.x === x && this.y === y;
  };

  Wilson.prototype.isVisited = function(x, y) {
    return this.visits[x + ":" + y] != null;
  };

  Wilson.prototype.addVisit = function(x, y, dir) {
    return this.visits[x + ":" + y] = dir != null ? dir : 0;
  };

  Wilson.prototype.exitTaken = function(x, y) {
    return this.visits[x + ":" + y];
  };

  Wilson.prototype.startStep = function() {
    var x, y;
    x = this.rand.nextInteger(this.maze.width);
    y = this.rand.nextInteger(this.maze.height);
    this.maze.carve(x, y, this.IN);
    this.updateAt(x, y);
    this.remaining--;
    return this.state = 1;
  };

  Wilson.prototype.startWalkStep = function() {
    var results;
    this.visits = {};
    results = [];
    while (true) {
      this.x = this.rand.nextInteger(this.maze.width);
      this.y = this.rand.nextInteger(this.maze.height);
      if (this.maze.isBlank(this.x, this.y)) {
        this.eventAt(this.x, this.y);
        this.state = 2;
        this.start = {
          x: this.x,
          y: this.y
        };
        this.addVisit(this.x, this.y);
        this.updateAt(this.x, this.y);
        break;
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Wilson.prototype.walkStep = function() {
    var direction, i, len, nx, ny, ref, ref1, results, x, y;
    ref = this.rand.randomDirections();
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      direction = ref[i];
      nx = this.x + Maze.Direction.dx[direction];
      ny = this.y + Maze.Direction.dy[direction];
      if (this.maze.isValid(nx, ny)) {
        ref1 = [this.x, this.y, nx, ny], x = ref1[0], y = ref1[1], this.x = ref1[2], this.y = ref1[3];
        if (this.isVisited(nx, ny)) {
          this.eraseLoopFrom(nx, ny);
        } else {
          this.addVisit(x, y, direction);
        }
        this.updateAt(x, y);
        this.updateAt(nx, ny);
        if (!this.maze.isBlank(nx, ny)) {
          this.x = this.start.x;
          this.y = this.start.y;
          this.state = 3;
          this.eventAt(this.x, this.y);
        }
        break;
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Wilson.prototype.resetVisits = function() {
    var dir, key, ref, ref1, results, x, y;
    ref = this.visits;
    results = [];
    for (key in ref) {
      dir = ref[key];
      ref1 = key.split(":"), x = ref1[0], y = ref1[1];
      delete this.visits[key];
      results.push(this.updateAt(x, y));
    }
    return results;
  };

  Wilson.prototype.runStep = function() {
    var dir, nx, ny, ref, x, y;
    if (this.remaining > 0) {
      dir = this.exitTaken(this.x, this.y);
      nx = this.x + Maze.Direction.dx[dir];
      ny = this.y + Maze.Direction.dy[dir];
      if (!this.maze.isBlank(nx, ny)) {
        this.resetVisits();
        this.state = 1;
      }
      this.maze.carve(this.x, this.y, dir);
      this.maze.carve(nx, ny, Maze.Direction.opposite[dir]);
      ref = [this.x, this.y, nx, ny], x = ref[0], y = ref[1], this.x = ref[2], this.y = ref[3];
      if (this.state === 1) {
        delete this.x;
        delete this.y;
      }
      this.updateAt(x, y);
      this.updateAt(nx, ny);
      this.remaining--;
    }
    return this.remaining > 0;
  };

  Wilson.prototype.step = function() {
    if (this.remaining > 0) {
      switch (this.state) {
        case 0:
          this.startStep();
          break;
        case 1:
          this.startWalkStep();
          break;
        case 2:
          this.walkStep();
          break;
        case 3:
          this.runStep();
      }
    }
    return this.remaining > 0;
  };

  Wilson.prototype.eraseLoopFrom = function(x, y) {
    var dir, key, nx, ny, ref, results;
    results = [];
    while (true) {
      dir = this.exitTaken(x, y);
      if (!dir) {
        break;
      }
      nx = x + Maze.Direction.dx[dir];
      ny = y + Maze.Direction.dy[dir];
      key = x + ":" + y;
      delete this.visits[key];
      this.updateAt(x, y);
      results.push((ref = [nx, ny], x = ref[0], y = ref[1], ref));
    }
    return results;
  };

  return Wilson;

})(Maze.Algorithm);

// ------ lib/algorithms/growing_binary_tree.js -------
// Generated by CoffeeScript 1.12.4

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Maze.Algorithms.GrowingBinaryTree = (function(superClass) {
  extend(GrowingBinaryTree, superClass);

  function GrowingBinaryTree() {
    return GrowingBinaryTree.__super__.constructor.apply(this, arguments);
  }

  GrowingBinaryTree.prototype.runStep = function() {
    var cell, count, direction, i, index, len, nx, ny, ref;
    index = this.nextCell();
    cell = this.cells.splice(index, 1)[0];
    this.maze.uncarve(cell.x, cell.y, this.QUEUE);
    this.updateAt(cell.x, cell.y);
    count = 0;
    ref = this.rand.randomDirections();
    for (i = 0, len = ref.length; i < len; i++) {
      direction = ref[i];
      nx = cell.x + Maze.Direction.dx[direction];
      ny = cell.y + Maze.Direction.dy[direction];
      if (this.maze.isValid(nx, ny) && this.maze.isBlank(nx, ny)) {
        this.maze.carve(cell.x, cell.y, direction);
        this.maze.carve(nx, ny, Maze.Direction.opposite[direction]);
        this.enqueue(nx, ny);
        this.updateAt(cell.x, cell.y);
        this.updateAt(nx, ny);
        count += 1;
        if (count > 1) {
          return;
        }
      }
    }
  };

  return GrowingBinaryTree;

})(Maze.Algorithms.GrowingTree);

